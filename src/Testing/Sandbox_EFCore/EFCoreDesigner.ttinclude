<#@ assembly name="System.Core"
#><#@ assembly name="System.Data.Linq"
#><#@ assembly name="EnvDTE"
#><#@ assembly name="System.Xml"
#><#@ assembly name="System.Xml.Linq"
#><#@ import namespace="System.Collections.Generic"
#><#@ import namespace="System.IO"
#><#@ import namespace="System.Linq" #><#+

// EFDesigner v1.3.0.5
// Copyright (c) 2017-2019 Michael Sawczyn
// https://github.com/msawczyn/EFDesigner

void GenerateEFCore(Manager manager, ModelRoot modelRoot)
{
   // Entities

   string dir = modelRoot.EntityOutputDirectory;
   manager.StartNewFile(Path.Combine(dir, $"NavigationProperty.cs"));
   WriteBidirectionalUtilityFile(modelRoot);

   foreach (ModelClass modelClass in modelRoot.Classes)
   {
      dir = modelClass.IsDependentType ? modelRoot.StructOutputDirectory : modelRoot.EntityOutputDirectory;
      if (!string.IsNullOrEmpty(modelClass.OutputDirectory)) dir = modelClass.OutputDirectory;
      manager.StartNewFile(Path.Combine(dir, $"{modelClass.Name}.{modelRoot.FileNameMarker}.cs"));
      WriteClass(modelClass);

      // Shadowed join entities

      foreach (Association association in Association.GetLinksToSources(modelClass)
                                         .Where(x => x.TargetMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany &&
                                                     x.SourceMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany))
      {
        dir = modelRoot.EntityOutputDirectory;
        manager.StartNewFile(Path.Combine(dir, $"{GetJoinClassName(association)}.{modelRoot.FileNameMarker}.cs"));
        WriteJoinClass(association);
      }
   }


   // Enums

   foreach (ModelEnum modelEnum in modelRoot.Enums)
   {
      dir = !string.IsNullOrEmpty(modelEnum.OutputDirectory) ? modelEnum.OutputDirectory : modelRoot.EnumOutputDirectory;
      manager.StartNewFile(Path.Combine(dir, $"{modelEnum.Name}.{modelRoot.FileNameMarker}.cs"));
      WriteEnum(modelEnum);
   }

   // not supported as of EF Core 2.2
   // manager.StartNewFile(Path.Combine(modelRoot.ContextOutputDirectory, $"{modelRoot.EntityContainerName}DatabaseInitializer.{modelRoot.FileNameMarker}.cs"));
   // WriteDatabaseInitializerEFCore(modelRoot);
   
   // not supported as of EF Core 2.2
   // manager.StartNewFile(Path.Combine(modelRoot.ContextOutputDirectory, $"{modelRoot.EntityContainerName}DbMigrationConfiguration.{modelRoot.FileNameMarker}.cs"));
   // WriteMigrationConfigurationEFCore(modelRoot);

   manager.StartNewFile(Path.Combine(modelRoot.ContextOutputDirectory, $"{modelRoot.EntityContainerName}.{modelRoot.FileNameMarker}.cs"));
   WriteDbContextEFCore(modelRoot);
}

List<string> GetAdditionalUsingStatementsEFCore(ModelRoot modelRoot)
{
   List<string> result = new List<string>();
   List<string> attributeTypes = modelRoot.Classes.SelectMany(c => c.Attributes).Select(a => a.Type).Distinct().ToList();

   if (attributeTypes.Any(t => t.IndexOf("Geometry", StringComparison.Ordinal) > -1 || t.IndexOf("Geography", StringComparison.Ordinal) > -1))
   {
      result.Add("using System.Data.Entity.Spatial;"); 
   }

   return result;
}

void WriteDbContextEFCore(ModelRoot modelRoot)
{
   List<string> segments = new List<string>();

   Output("using System;");
   Output("using System.Collections.Generic;");
   Output("using System.Linq;");
   Output("using System.ComponentModel.DataAnnotations.Schema;");
   Output("using Microsoft.EntityFrameworkCore;");
   NL();

   BeginNamespace(modelRoot.Namespace);

   if (!string.IsNullOrEmpty(modelRoot.Summary))
   {
      Output("/// <summary>");
      WriteCommentBody(modelRoot.Summary);
      Output("/// </summary>");
      if (!string.IsNullOrEmpty(modelRoot.Description))
      {
         Output("/// <remarks>");
         WriteCommentBody(modelRoot.Description);
         Output("/// </remarks>");
      }
   }
   else
   {
      Output("/// <inheritdoc/>");
   }

   Output($"{modelRoot.EntityContainerAccess.ToString().ToLower()} partial class {modelRoot.EntityContainerName} : Microsoft.EntityFrameworkCore.DbContext");
   Output("{");

   PluralizationService pluralizationService = ModelRoot.PluralizationService;
   
   /***********************************************************************/
   // generate DBSets
   /***********************************************************************/
   
   IEnumerable<ModelClass> classesWithTables = null;

   switch (modelRoot.InheritanceStrategy)
   {
      case CodeStrategy.TablePerType:
         classesWithTables = modelRoot.Classes.Where(mc => !mc.IsDependentType).OrderBy(x => x.Name);
         break;
      case CodeStrategy.TablePerConcreteType:
         classesWithTables = modelRoot.Classes.Where(mc => !mc.IsDependentType && !mc.IsAbstract).OrderBy(x => x.Name);
         break;
      case CodeStrategy.TablePerHierarchy:
         classesWithTables = modelRoot.Classes.Where(mc => !mc.IsDependentType && mc.Superclass == null).OrderBy(x => x.Name);
         break;
   }

   if (classesWithTables != null)
   {
      Output("#region DbSets");
      
      foreach (ModelClass modelClass in modelRoot.Classes.Where(x => !x.IsDependentType).OrderBy(x => x.Name))
      {
         string dbSetName;

         if (!string.IsNullOrEmpty(modelClass.DbSetName))
            dbSetName = modelClass.DbSetName;
         else 
            dbSetName = pluralizationService?.IsSingular(modelClass.Name) == true
               ? pluralizationService.Pluralize(modelClass.Name)
               : modelClass.Name;

         if (!string.IsNullOrEmpty(modelClass.Summary))
         {
            NL();
            Output("/// <summary>");
            WriteCommentBody($"Repository for {modelClass.FullName} - {modelClass.Summary}");
            Output("/// </summary>");
         }
         Output($"{modelRoot.DbSetAccess.ToString().ToLower()} virtual Microsoft.EntityFrameworkCore.DbSet<{modelClass.FullName}> {dbSetName} {{ get; set; }}");
      }

      Output("#endregion DbSets");
      NL();
   }

   /***********************************************************************/
   // constructors
   /***********************************************************************/

   if (!string.IsNullOrEmpty(modelRoot.ConnectionString) || !string.IsNullOrEmpty(modelRoot.ConnectionStringName))
   {
      string connectionString = string.IsNullOrEmpty(modelRoot.ConnectionString) 
                                   ? $"Name={modelRoot.ConnectionStringName}"
                                   : modelRoot.ConnectionString;

      Output("/// <summary>");
      Output("/// Default connection string");
      Output("/// </summary>");
      Output($"public static string ConnectionString {{ get; set; }} = @\"{connectionString}\";");
      NL();
   }
   
   //Output("/// <inheritdoc />");
   //Output($"public {modelRoot.EntityContainerName}() : base()");
   //Output("{");
   //Output("}");
   //NL();
   Output("/// <inheritdoc />");
   Output($"public {modelRoot.EntityContainerName}(DbContextOptions<{modelRoot.EntityContainerName}> options) : base(options)");
   Output("{");
   Output("}");
   NL();
   
   Output("partial void CustomInit(DbContextOptionsBuilder optionsBuilder);");
   NL();

   Output("/// <inheritdoc />");
   Output($"protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)");
   Output("{");

   segments.Clear();

   if (modelRoot.GetEntityFrameworkPackageVersionNum() >= 2.1 && modelRoot.LazyLoadingEnabled)
      segments.Add("UseLazyLoadingProxies()");

   if (segments.Any())
   {
      segments.Insert(0, "optionsBuilder");

      WriteLine(segments, modelRoot.ChopMethodChains);
      NL();
   }

   Output("CustomInit(optionsBuilder);");
   Output("}");
   NL();
   
   Output("partial void OnModelCreatingImpl(ModelBuilder modelBuilder);");
   Output("partial void OnModelCreatedImpl(ModelBuilder modelBuilder);");
   NL();
   
   /***********************************************************************/
   // OnModelCreating 
   /***********************************************************************/
   Output("/// <inheritdoc />");
   Output("protected override void OnModelCreating(ModelBuilder modelBuilder)");
   Output("{");
   Output("base.OnModelCreating(modelBuilder);");
   Output("OnModelCreatingImpl(modelBuilder);");
   NL();
   
   Output($"modelBuilder.HasDefaultSchema(\"{modelRoot.DatabaseSchema}\");");

   Sawczyn.EFDesigner.EFModel.Multiplicity[] singles = { Sawczyn.EFDesigner.EFModel.Multiplicity.One, Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne };
   Sawczyn.EFDesigner.EFModel.Multiplicity[] multiples = { Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany };
   List<Association> visited = new List<Association>();
   List<string> foreignKeyColumns = new List<string>();

   foreach (ModelClass modelClass in modelRoot.Classes.OrderBy(x => x.Name))
   {
      segments.Clear();
      foreignKeyColumns.Clear();
      NL();

      // class level
      segments.Add($"modelBuilder.{(modelClass.IsDependentType ? "Owned" : "Entity")}<{modelClass.FullName}>()");

      if (!modelClass.IsDependentType)
      {
         // note: this must come before the 'ToTable' call or there's a runtime error
         if (modelRoot.InheritanceStrategy == CodeStrategy.TablePerConcreteType && modelClass.Superclass != null)
            segments.Add("Map(x => x.MapInheritedProperties())");

         if (classesWithTables.Contains(modelClass))
         {
            if (modelClass.DatabaseSchema == modelClass.ModelRoot.DatabaseSchema)
               segments.Add($"ToTable(\"{modelClass.TableName}\")");
            else
               segments.Add($"ToTable(\"{modelClass.TableName}\", \"{modelClass.DatabaseSchema}\")");

            // primary key code segments must be output last, since HasKey returns a different type
            List<ModelAttribute> identityAttributes = modelClass.IdentityAttributes.ToList();
            if (identityAttributes.Count() == 1)
               segments.Add($"HasKey(t => t.{identityAttributes[0].Name})");
            else if (identityAttributes.Count() > 1)
               segments.Add($"HasKey(t => new {{ t.{string.Join(", t.", identityAttributes.Select(ia => ia.Name))} }})");
         }
      }

      if (segments.Count > 1)
         WriteLine(segments, modelRoot.ChopMethodChains);

     // indexed properties
      foreach (ModelAttribute indexed in modelClass.Attributes.Where(x => x.Indexed && !x.IsIdentity))
      {
         segments.Clear();
         string attributeName = !indexed.AutoProperty ? $"_{indexed.Name}" : indexed.Name;
         segments.Add($"modelBuilder.Entity<{modelClass.FullName}>().HasIndex(t => t.{attributeName})");

         if (indexed.IndexedUnique) 
            segments.Add("IsUnique()");

         WriteLine(segments, modelRoot.ChopMethodChains);
     }

      // attribute level
      foreach (ModelAttribute modelAttribute in modelClass.Attributes.Where(x => x.Persistent && !SpatialTypes.Contains(x.Type)))
      {
         segments.Clear();

         if (modelAttribute.MaxLength != null && modelAttribute.MaxLength > 0)
            segments.Add($"HasMaxLength({modelAttribute.MaxLength})");
         if (modelAttribute.Required)
            segments.Add("IsRequired()");
         if (modelAttribute.ColumnName != modelAttribute.Name && !string.IsNullOrEmpty(modelAttribute.ColumnName))
            segments.Add($"HasColumnName(\"{modelAttribute.ColumnName}\")");
         if (!modelAttribute.AutoProperty)
            segments.Add($"HasField(\"_{modelAttribute.Name}\")");
         if (!string.IsNullOrEmpty(modelAttribute.ColumnType) && modelAttribute.ColumnType.ToLowerInvariant() != "default")
         {
            if (modelAttribute.ColumnType.ToLowerInvariant() == "varchar" || modelAttribute.ColumnType.ToLowerInvariant() == "nvarchar" || modelAttribute.ColumnType.ToLowerInvariant() == "char")
               segments.Add($"HasColumnType(\"{modelAttribute.ColumnType}({(modelAttribute.MaxLength != null && modelAttribute.MaxLength > 0 ? modelAttribute.MaxLength.ToString() : "max")})\")");
            else
               segments.Add($"HasColumnType(\"{modelAttribute.ColumnType}\")");
         }
         if (modelAttribute.IsConcurrencyToken)
            segments.Add("IsRowVersion()");
         
         if (modelAttribute.IsIdentity)
         {
            if (modelAttribute.IdentityType == IdentityType.AutoGenerated)
               segments.Add("ValueGeneratedOnAdd()");
            else // if (modelAttribute.IdentityType == IdentityType.Manual)
               segments.Add("ValueGeneratedNever()");
         }

         if (segments.Any())
         {
            segments.Insert(0, $"modelBuilder.{(modelClass.IsDependentType ? "Owned" : "Entity")}<{modelClass.FullName}>()");
            segments.Insert(1, $"Property(t => t.{modelAttribute.Name})");

            WriteLine(segments, modelRoot.ChopMethodChains);
         }
      }

      bool hasDefinedConcurrencyToken = modelClass.AllAttributes.Any(x => x.IsConcurrencyToken);
      if (!hasDefinedConcurrencyToken && modelClass.EffectiveConcurrency == ConcurrencyOverride.Optimistic)
         Output($@"modelBuilder.Entity<{modelClass.FullName}>().Property<byte[]>(""Timestamp"").IsConcurrencyToken();");

      // Navigation endpoints are distingished as Source and Target. They are also distinguished as Principal
      // and Dependent. How do these map?
      // In the case of one-to-one or zero-to-one-to-zero-to-one, it's model dependent and the user has to tell us
      // In all other cases, we can tell by the cardinalities of the associations
      // What matters is the Principal and Dependent classifications, so we look at those. 
      // Source and Target are accidents of where the user started drawing the association.

      // navigation properties

      // ****************************************************************
      // unidirectional, not many-to-many, both ends are entities
      foreach (UnidirectionalAssociation association in Association.GetLinksToTargets(modelClass)
                                                                   .OfType<UnidirectionalAssociation>()
                                                                   .Where(x => !x.Target.IsDependentType && 
                                                                                 (x.TargetMultiplicity != Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany || 
                                                                                  x.SourceMultiplicity != Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany)))
      {
         if (visited.Contains(association)) continue;
         visited.Add(association);

         segments.Clear();
         segments.Add($"modelBuilder.Entity<{modelClass.FullName}>()");
         bool required = false;

         switch (association.TargetMultiplicity) // realized by property on source
         {
            case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany:
               segments.Add($"HasMany(x => x.{association.TargetPropertyName})");
               break;
            case Sawczyn.EFDesigner.EFModel.Multiplicity.One:
               segments.Add($"HasOne(x => x.{association.TargetPropertyName})");
               break;
            case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne:
               segments.Add($"HasOne(x => x.{association.TargetPropertyName})");
               break;
            //case Sawczyn.EFDesigner.EFModel.Multiplicity.OneMany:
            //   segments.Add($"HasMany(x => x.{association.TargetPropertyName})");
            //   break;
         }

         string columnPrefix = association.SourceRole == EndpointRole.Dependent ? "" : (association.Target.Name + "_");

         switch (association.SourceMultiplicity) // realized by shadow property on target
         {
            case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany:
               if (association.TargetMultiplicity != Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany)
               {
                  segments.Add("WithMany()");
                  segments.Add($"HasForeignKey(\"{columnPrefix}{association.TargetPropertyName}_Id\")");
               }
               else
                  continue;
               break;
            case Sawczyn.EFDesigner.EFModel.Multiplicity.One:
               segments.Add("WithOne()");
               if (association.TargetMultiplicity != Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany)
                  segments.Add($"HasForeignKey<{association.Source.FullName}>(\"{columnPrefix}{association.TargetPropertyName}_Id\")");
               else
                  segments.Add($"HasForeignKey(\"{columnPrefix}{association.TargetPropertyName}_Id\")");
               required = true;
               break;
            case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne:
               segments.Add("WithOne()");
               if (association.TargetMultiplicity != Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany)
                  segments.Add($"HasForeignKey<{association.Source.FullName}>(\"{columnPrefix}{association.TargetPropertyName}_Id\")");
               else
                  segments.Add($"HasForeignKey(\"{columnPrefix}{association.TargetPropertyName}_Id\")");
               break;
            //case Sawczyn.EFDesigner.EFModel.Multiplicity.OneMany:
            //   segments.Add("HasMany()");
            //   break;
         }

         if (required)
            segments.Add("IsRequired()");

         if (association.TargetRole == EndpointRole.Principal || association.SourceRole == EndpointRole.Principal)
         {
            DeleteAction deleteAction = (association.SourceRole == EndpointRole.Principal) 
                                          ? association.SourceDeleteAction 
                                          : association.TargetDeleteAction;
            switch (deleteAction)
            {
               case DeleteAction.None:
                  segments.Add("OnDelete(DeleteBehavior.Restrict)");
                  break;
               case DeleteAction.Cascade:
                  segments.Add("OnDelete(DeleteBehavior.Cascade)");
                  break;
            }
         }

         WriteLine(segments, modelRoot.ChopMethodChains);
      }

      // ****************************************************************
      // unidirectional, not many-to-many, target is a dependent type

      foreach (UnidirectionalAssociation association in Association.GetLinksToTargets(modelClass)
                                                                   .OfType<UnidirectionalAssociation>()
                                                                   .Where(x => x.Target.IsDependentType  && 
                                                                                 (x.TargetMultiplicity != Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany || 
                                                                                  x.SourceMultiplicity != Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany)))
      {
         if (association.TargetMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne ||
             association.TargetMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.One)
         {
            Output($"modelBuilder.Entity<{modelClass.FullName}>().OwnsOne(x => x.{association.TargetPropertyName});");
         }
         else
         {
            Output($"// Dependent 1-many association seen ({association.TargetPropertyName}). Code generation still unsupported in designer.");
         }
      }

      // ****************************************************************
      // bidirectional, not many-to-many

      foreach (BidirectionalAssociation association in Association.GetLinksToSources(modelClass)
                                                                  .OfType<BidirectionalAssociation>()
                                                                  .Where(x => x.TargetMultiplicity != Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany || 
                                                                              x.SourceMultiplicity != Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany))
      {
         if (visited.Contains(association)) continue;
         visited.Add(association);

         // TODO: fix cascade delete
         bool required = false;

         segments.Clear();
         segments.Add($"modelBuilder.Entity<{modelClass.FullName}>()");

         switch (association.SourceMultiplicity) // realized by property on target
         {
            case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany:
               // TODO: Implement many-to-many
               if (association.TargetMultiplicity != Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany)
                  segments.Add($"HasMany(x => x.{association.SourcePropertyName})");
               else
                  continue;
               break;
            case Sawczyn.EFDesigner.EFModel.Multiplicity.One:
               segments.Add($"HasOne(x => x.{association.SourcePropertyName})");
               break;
            case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne:
               segments.Add($"HasOne(x => x.{association.SourcePropertyName})");
               break;
            //case Sawczyn.EFDesigner.EFModel.Multiplicity.OneMany:
            //   segments.Add($"HasMany(x => x.{association.SourcePropertyName})");
            //   break;
         }

         switch (association.TargetMultiplicity) // realized by property on source
         {
            case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany:
               // TODO: Implement many-to-many
               if (association.SourceMultiplicity != Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany)
                  segments.Add($"WithMany(x => x.{association.TargetPropertyName})");
               else
                  continue;
               break;
            case Sawczyn.EFDesigner.EFModel.Multiplicity.One:
               segments.Add($"WithOne(x => x.{association.TargetPropertyName})");
               required = true;
               break;
            case Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroOne:
               segments.Add($"WithOne(x => x.{association.TargetPropertyName})");
               break;
            //case Sawczyn.EFDesigner.EFModel.Multiplicity.OneMany:
            //   segments.Add($"HasMany(x => x.{association.TargetPropertyName})");
            //   break;
         }

         string foreignKeySegment = CreateForeignKeyColumnSegmentEFCore(association, 
                                                                        foreignKeyColumns, 
                                                                        association.SourceMultiplicity != Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany 
                                                                     && association.TargetMultiplicity != Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany);
         if (foreignKeySegment != null) 
            segments.Add(foreignKeySegment);

         if (required)
            segments.Add("IsRequired()");

         if (association.TargetRole == EndpointRole.Principal || association.SourceRole == EndpointRole.Principal)
         {
            DeleteAction deleteAction = (association.SourceRole == EndpointRole.Principal) 
                                          ? association.SourceDeleteAction 
                                          : association.TargetDeleteAction;
            switch (deleteAction)
            {
               case DeleteAction.None:
                  segments.Add("OnDelete(DeleteBehavior.Restrict)");
                  break;
               case DeleteAction.Cascade:
                  segments.Add("OnDelete(DeleteBehavior.Cascade)");
                  break;
            }
         }

         WriteLine(segments, modelRoot.ChopMethodChains);
      }

      // ****************************************************************
      // many-to-many

      foreach (Association association in Association.GetLinksToTargets(modelClass)
                                                     .Where(x => x.TargetMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany && 
                                                                 x.SourceMultiplicity == Sawczyn.EFDesigner.EFModel.Multiplicity.ZeroMany))
      {
         if (visited.Contains(association)) continue;
         visited.Add(association);

         segments.Clear();
         segments.Add($"modelBuilder.Entity<{association.Source.FullName}>()");
         segments.Add($"Ignore(x => x.{association.TargetPropertyName})");
         WriteLine(segments, modelRoot.ChopMethodChains);

         if (association is BidirectionalAssociation b)
         {
            segments.Add($"modelBuilder.Entity<{b.Target.FullName}>()");
            segments.Add($"Ignore(x => x.{b.SourcePropertyName})");
            WriteLine(segments, modelRoot.ChopMethodChains);
         }
         NL();

         string joinClassName = GetJoinClassName(association);

         segments.Add($"modelBuilder.Entity<global::{modelClass.ModelRoot.Namespace}.{joinClassName}>()");
         segments.Add($"ToTable(\"{joinClassName}\")");

         List<string> lhsKeyNames = association.Source.IdentityAttributeNames.Select(n => $"LHS_{n}").ToList();
         List<string> rhsKeyNames = association.Target.IdentityAttributeNames.Select(n => $"RHS_{n}").ToList();
         List<string> keyNames = lhsKeyNames.Union(rhsKeyNames).ToList();
         segments.Add($"HasKey(t => new {{ t.{string.Join(", t.", keyNames)} }})");

         WriteLine(segments, modelRoot.ChopMethodChains);

         segments.Add($"modelBuilder.Entity<global::{modelClass.ModelRoot.Namespace}.{joinClassName}>()");
         segments.Add($"HasOne(x => x.LHS)");
         segments.Add($"WithMany()");

         if (lhsKeyNames.Count == 1)
            segments.Add($"HasForeignKey(x => x.{lhsKeyNames[0]})");
         else
            segments.Add($"HasForeignKey(x => new {{ x.{string.Join(", x.", lhsKeyNames)} }})");

         segments.Add($"IsRequired()");

         WriteLine(segments, modelRoot.ChopMethodChains);

         segments.Add($"modelBuilder.Entity<global::{modelClass.ModelRoot.Namespace}.{joinClassName}>()");
         segments.Add($"HasOne(x => x.RHS)");
         segments.Add($"WithMany()");

         if (rhsKeyNames.Count == 1)
            segments.Add($"HasForeignKey(x => x.{rhsKeyNames[0]})");
         else
            segments.Add($"HasForeignKey(x => new {{ x.{string.Join(", x.", rhsKeyNames)} }})");

         segments.Add($"IsRequired()");

         WriteLine(segments, modelRoot.ChopMethodChains);
      }
   }
   
   NL();
   
   Output("OnModelCreatedImpl(modelBuilder);");
   Output("}");

   Output("}");

   EndNamespace(modelRoot.Namespace);
}

string GetJoinClassName(Association association) 
{
   if (association is UnidirectionalAssociation u)
      return $"{u.Source.Name}_{u.TargetPropertyName}_x_{u.Source.Name}";
   if (association is BidirectionalAssociation b)
      return $"{b.Source.Name}_{b.TargetPropertyName}_x_{b.Target.Name}_{b.SourcePropertyName}";
   return null;
}

void WriteJoinClass(Association association)
{
   Output("using System;");

   List<string> additionalUsings = GetAdditionalUsingStatementsEFCore(association.Source.ModelRoot);
   if (additionalUsings.Any())
      Output(string.Join("\n", additionalUsings));
   NL();

   BeginNamespace(association.Source.ModelRoot.Namespace);
   string joinClassName = GetJoinClassName(association);

   Output("/// <summary>");
   Output(association is BidirectionalAssociation bidirectional
            ? $"/// Class linking many-to-many association between {association.Source.FullName}.{association.TargetPropertyName} and {association.Target.FullName}.{bidirectional.SourcePropertyName}"
            : $"/// Class linking many-to-many association between {association.Source.FullName}.{association.TargetPropertyName} and {association.Target}");
   Output("/// </summary>");

   Output($"public sealed class {joinClassName} : IJoin<{association.Source.FullName}>, IJoin<{association.Target.FullName}>, IEquatable<{joinClassName}>");
   Output($"{{");
   Output($"public {joinClassName}()");
   Output($"{{");
   Output($"}}");
   NL();

   Output($"public {association.Source.FullName} LHS {{ get; set; }}");
   Output($"public Int32 LHS_Id {{ get; set; }}");
   NL();

   Output($"public {association.Target.FullName} RHS {{ get; set; }}");
   Output($"public Int32 RHS_Id {{ get; set; }}");
   NL();

   Output($"{association.Source.FullName} IJoin<{association.Source.FullName}>.Navigation");
   Output($"{{");
   Output($"get {{ return LHS; }}");
   Output($"set {{ LHS = value; }}");
   Output($"}}");
   NL();

   Output($"{association.Target.FullName} IJoin<{association.Target.FullName}>.Navigation");
   Output($"{{");
   Output($"get {{ return RHS; }}");
   Output($"set {{ RHS = value; }}");
   Output($"}}");
   NL();

   Output($"#region IEquatable");
   NL();

   Output($"/// <summary>Determines whether the specified object is equal to the current object.</summary>");
   Output($"/// <param name=\"obj\">The object to compare with the current object. </param>");
   Output($"/// <returns>");
   Output($"/// <see langword=\"true\" /> if the specified object  is equal to the current object; otherwise, <see langword=\"false\" />.</returns>");
   Output($"public override bool Equals(object obj)");
   Output($"{{");
   Output($"if (ReferenceEquals(null, obj)) return false;");
   Output($"if (ReferenceEquals(this, obj)) return true;");
   Output($"if (obj.GetType() != this.GetType()) return false;");
   Output($"return Equals(({joinClassName})obj);");
   Output($"}}");
   NL();

   Output($"/// <summary>Indicates whether the current object is equal to another object of the same type.</summary>");
   Output($"/// <param name=\"other\">An object to compare with this object.</param>");
   Output($"/// <returns>");
   Output($"/// <see langword=\"true\" /> if the current object is equal to the <paramref name=\"other\" /> parameter; otherwise, <see langword=\"false\" />.</returns>");
   Output($"public bool Equals({joinClassName} other)");
   Output($"{{");
   Output($"if (ReferenceEquals(null, other)) return false;");
   Output($"if (ReferenceEquals(this, other)) return true;");
   Output($"return LHS.Equals(other.LHS) && RHS.Equals(other.RHS);");
   Output($"}}");
   NL();

   Output($"/// <summary>Serves as the default hash function. </summary>");
   Output($"/// <returns>A hash code for the current object.</returns>");
   Output($"public override int GetHashCode()");
   Output($"{{");
   Output($"unchecked");
   Output($"{{");
   Output($"return (LHS.GetHashCode() * 397) ^ RHS.GetHashCode();");
   Output($"}}");
   Output($"}}");
   NL();

   Output($"/// <summary>Returns a value that indicates whether the values of two <see cref=\"T:Sandbox_EFCore{joinClassName}\" /> objects are equal.</summary>");
   Output($"/// <param name=\"left\">The first value to compare.</param>");
   Output($"/// <param name=\"right\">The second value to compare.</param>");
   Output($"/// <returns>true if the <paramref name=\"left\" /> and <paramref name=\"right\" /> parameters have the same value; otherwise, false.</returns>");
   Output($"public static bool operator ==({joinClassName} left, {joinClassName} right)");
   Output($"{{");
   Output($"return Equals(left, right);");
   Output($"}}");
   NL();

   Output($"/// <summary>Returns a value that indicates whether two <see cref=\"T:Sandbox_EFCore{joinClassName}\" /> objects have different values.</summary>");
   Output($"/// <param name=\"left\">The first value to compare.</param>");
   Output($"/// <param name=\"right\">The second value to compare.</param>");
   Output($"/// <returns>true if <paramref name=\"left\" /> and <paramref name=\"right\" /> are not equal; otherwise, false.</returns>");
   Output($"public static bool operator !=({joinClassName} left, {joinClassName} right)");
   Output($"{{");
   Output($"return !Equals(left, right);");
   Output($"}}");
   NL();

   Output($"#endregion");
   NL();

   Output($"}}");

   EndNamespace(association.Source.ModelRoot.Namespace);
   NL();
}

void WriteBidirectionalUtilityFile(ModelRoot modelRoot)
{
   Output("// Based on the work done at https://github.com/ZBAGI/EntityFramework-ManyToMany/tree/master/EntityFramework-ManyToMany/Relationship");
   Output("using System;");
   Output("using System.Collections;");
   Output("using System.Collections.Generic;");
   Output("using System.Linq;");

   NL();

   BeginNamespace(modelRoot.Namespace);

   Output($"public interface IJoin<TEntity>");
   Output($"{{");
   Output($"TEntity Navigation {{ get; set; }}");
   Output($"}}");
   NL();

   Output($"public class NavigationProperty<TOwner, TEntity, TJoin> ");
   Output($"   : ICollection<TEntity> where TJoin : IJoin<TEntity>, IJoin<TOwner>, new()");
   Output($"{{");
   Output($"private readonly TOwner OwnerEntity;");
   Output($"private ICollection<TJoin> Collection;");
   NL();

   Output($"public NavigationProperty(TOwner ownerEntity)");
   Output($"{{");
   Output($"OwnerEntity = ownerEntity;");
   Output($"}}");
   NL();

   Output($"/// <summary>Returns an enumerator that iterates through the collection.</summary>");
   Output($"/// <returns>An enumerator that can be used to iterate through the collection.</returns>");
   Output($"public IEnumerator<TEntity> GetEnumerator()");
   Output($"{{");
   Output($"return GetCollection().Select(e => ((IJoin<TEntity>)e).Navigation).GetEnumerator();");
   Output($"}}");
   NL();

   Output($"/// <summary>Returns an enumerator that iterates through a collection.</summary>");
   Output($"/// <returns>An <see cref=\"T:System.Collections.IEnumerator\" /> object that can be used to iterate through the collection.</returns>");
   Output($"IEnumerator IEnumerable.GetEnumerator()");
   Output($"{{");
   Output($"return GetEnumerator();");
   Output($"}}");
   NL();

   Output($"/// <summary>Adds an item to the <see cref=\"T:System.Collections.Generic.ICollection`1\" />.</summary>");
   Output($"/// <param name=\"item\">The object to add to the <see cref=\"T:System.Collections.Generic.ICollection`1\" />.</param>");
   Output($"/// <exception cref=\"T:System.NotSupportedException\">The <see cref=\"T:System.Collections.Generic.ICollection`1\" /> is read-only.</exception>");
   Output($"public void Add(TEntity item)");
   Output($"{{");
   Output($"if (!Contains(item))");
   Output($"{{");
   Output($"TJoin entity = new TJoin();");
   Output($"((IJoin<TEntity>)entity).Navigation = item;");
   Output($"((IJoin<TOwner>)entity).Navigation = OwnerEntity;");
   Output($"GetCollection().Add(entity);");
   Output($"}}");
   Output($"}}");
   NL();

   Output($"/// <summary>Removes all items from the <see cref=\"T:System.Collections.Generic.ICollection`1\" />.</summary>");
   Output($"/// <exception cref=\"T:System.NotSupportedException\">The <see cref=\"T:System.Collections.Generic.ICollection`1\" /> is read-only. </exception>");
   Output($"public void Clear()");
   Output($"{{");
   Output($"GetCollection().Clear();");
   Output($"}}");
   NL();

   Output($"/// <summary>Determines whether the <see cref=\"T:System.Collections.Generic.ICollection`1\" /> contains a specific value.</summary>");
   Output($"/// <param name=\"item\">The object to locate in the <see cref=\"T:System.Collections.Generic.ICollection`1\" />.</param>");
   Output($"/// <returns>");
   Output($"/// <see langword=\"true\" /> if <paramref name=\"item\" /> is found in the <see cref=\"T:System.Collections.Generic.ICollection`1\" />; otherwise, <see langword=\"false\" />.</returns>");
   Output($"public bool Contains(TEntity item)");
   Output($"{{");
   Output($"return GetCollection().Any(e => Equals(item, e));");
   Output($"}}");
   NL();

   Output($"/// <summary>Copies the elements of the <see cref=\"T:System.Collections.Generic.ICollection`1\" /> to an <see cref=\"T:System.Array\" />, starting at a particular <see cref=\"T:System.Array\" /> index.</summary>");
   Output($"/// <param name=\"array\">The one-dimensional <see cref=\"T:System.Array\" /> that is the destination of the elements copied from <see cref=\"T:System.Collections.Generic.ICollection`1\" />. The <see cref=\"T:System.Array\" /> must have zero-based indexing.</param>");
   Output($"/// <param name=\"arrayIndex\">The zero-based index in <paramref name=\"array\" /> at which copying begins.</param>");
   Output($"/// <exception cref=\"T:System.ArgumentNullException\">");
   Output($"/// <paramref name=\"array\" /> is <see langword=\"null\" />.</exception>");
   Output($"/// <exception cref=\"T:System.ArgumentOutOfRangeException\">");
   Output($"/// <paramref name=\"arrayIndex\" /> is less than 0.</exception>");
   Output($"/// <exception cref=\"T:System.ArgumentException\">The number of elements in the source <see cref=\"T:System.Collections.Generic.ICollection`1\" /> is greater than the available space from <paramref name=\"arrayIndex\" /> to the end of the destination <paramref name=\"array\" />.</exception>");
   Output($"public void CopyTo(TEntity[] array, int arrayIndex)");
   Output($"{{");
   Output($"if (array == null) throw new ArgumentNullException(nameof(array));");
   Output($"if (arrayIndex < 0) throw new ArgumentOutOfRangeException(nameof(arrayIndex));");
   Output($"if (Count > array.Length - arrayIndex) throw new ArgumentException(\"The number of elements in the source ICollection is greater than the available space from arrayIndex to the end of the destination array\");");
   Output($"this.ToList().CopyTo(array, arrayIndex);");
   Output($"}}");
   NL();

   Output($"/// <summary>Removes the first occurrence of a specific object from the <see cref=\"T:System.Collections.Generic.ICollection`1\" />.</summary>");
   Output($"/// <param name=\"item\">The object to remove from the <see cref=\"T:System.Collections.Generic.ICollection`1\" />.</param>");
   Output($"/// <returns>");
   Output($"/// <see langword=\"true\" /> if <paramref name=\"item\" /> was successfully removed from the <see cref=\"T:System.Collections.Generic.ICollection`1\" />; otherwise, <see langword=\"false\" />. This method also returns <see langword=\"false\" /> if <paramref name=\"item\" /> is not found in the original <see cref=\"T:System.Collections.Generic.ICollection`1\" />.</returns>");
   Output($"/// <exception cref=\"T:System.NotSupportedException\">The <see cref=\"T:System.Collections.Generic.ICollection`1\" /> is read-only.</exception>");
   Output($"public bool Remove(TEntity item)");
   Output($"{{");
   Output($"return GetCollection().Remove(GetCollection().FirstOrDefault(e => Equals(item, e)));");
   Output($"}}");
   NL();

   Output($"/// <summary>Gets the number of elements contained in the <see cref=\"T:System.Collections.Generic.ICollection`1\" />.</summary>");
   Output($"/// <returns>The number of elements contained in the <see cref=\"T:System.Collections.Generic.ICollection`1\" />.</returns>");
   Output($"public int Count");
   Output($"{{");
   Output($"get {{ return GetCollection().Count; }}");
   Output($"}}");
   NL();

   Output($"/// <summary>Gets a value indicating whether the <see cref=\"T:System.Collections.Generic.ICollection`1\" /> is read-only.</summary>");
   Output($"/// <returns>");
   Output($"/// <see langword=\"true\" /> if the <see cref=\"T:System.Collections.Generic.ICollection`1\" /> is read-only; otherwise, <see langword=\"false\" />.</returns>");
   Output($"public bool IsReadOnly");
   Output($"{{");
   Output($"get {{ return GetCollection().IsReadOnly; }}");
   Output($"}}");
   NL();

   Output($"private static bool Equals(TEntity item, TJoin e)");
   Output($"{{");
   Output($"return Equals(((IJoin<TEntity>)e).Navigation, item);");
   Output($"}}");
   NL();

   Output($"private ICollection<TJoin> GetCollection()");
   Output($"{{");
   Output($"if (Collection == null)");
   Output($"   Collection = typeof(TOwner).GetProperties()");
   Output($"                              .SingleOrDefault(p => p.PropertyType == typeof(ICollection<TJoin>))");
   Output($"                             ?.GetValue(OwnerEntity, null) as ICollection<TJoin>;");
   NL();
   Output($"if (Collection == null)");
   Output($"   throw new NullReferenceException($\"Missing ICollection<{{typeof(TJoin).FullName}}> in entity type {{typeof(TOwner).FullName}} or collection haven't been initalized.\");");
   NL();
   Output($"return Collection;");
   Output($"}}");
   Output($"}}");

   EndNamespace(modelRoot.Namespace);
}

string CreateForeignKeyColumnSegmentEFCore(Association association, List<string> foreignKeyColumns, bool useGeneric)
{
   // foreign key definitions always go in the table representing the Dependent end of the association
   // if there is no dependent end (i.e., many-to-many), there are no foreign keys
   string nameBase = string.Empty;
   string dependentType = null;
   string principalType = null;

   if (association.SourceRole == EndpointRole.Dependent)
   {
      nameBase = association.TargetPropertyName; 
      dependentType = association.Source.FullName; 
      principalType = association.Target.FullName;
   }
   else if (association.TargetRole == EndpointRole.Dependent)
   {
      nameBase = association is BidirectionalAssociation b ? b.SourcePropertyName :  $"{association.Source.Name}.{association.TargetPropertyName}";
      dependentType = association.Target.FullName;
      principalType = association.Source.FullName;
   }
   else
      return null;

   string columnName = $"{nameBase}_Id";
   if (foreignKeyColumns.Contains(columnName))
   {
      int index = 0;
      do
      {
         columnName = $"{nameBase}{++index}_Id";
      } while (foreignKeyColumns.Contains(columnName));
   }
   foreignKeyColumns.Add(columnName);
   
   return useGeneric 
      ? $"HasForeignKey<{dependentType}>(\"{columnName}\")" 
      : $"HasForeignKey(\"{columnName}\")";
}
#>